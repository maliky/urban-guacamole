#+TITLE: Introduction à Haskell
#+STARTUP: fold
#+AUTHOR: Doc. Malik Koné
#+LANGUAGE: fr
#+LATEX_HEADER: \usepackage[french]{babel}
#+LATEX_HEADER: \usepackage[labelformat=empty]{caption}
#+LATEX_HEADER: \usepackage{verbatim}
#+LATEX_HEADER: \usepackage{hyperref}
#+OPTIONS: H:3 toc:2 num:t broken-links:t ^:{} date:t author:t title:t -:t


* Qu'est-ce que Haskell
** Préambule
Ce document n'aurait pas été possible sans le livre de Graham Hutton "Programming in Haskell (Cambridge, 2018)" ainsi que du [[https://www.futurelearn.com/courses/functional-programming-haskell][cours de futurLearn]] "progaming in Haskell"  et des [[https://github.com/WADAlliance/Haskell_Plutus_Course][notes du hackton Haskell et Plutus]] de WADA.  Merci

 
  Haskell est un langage programmation avancé, fonctionnel. Les fonctions y jouent un rôle très important.  On dit qu'elles sont de première classe.   En Haskell, la notion de type est centrale.   Un peu comme en mathématique toute fonction a un domaine de définition et un ensemble image.  Ils doivent être précisés avant de coder.

Nous donnons un aperçu des fonctions,  puis nous introduisons la notion de programmation fonctionnelle et nous présenterons les atouts majeurs de Haskell.
   
** Fonctions
 Une fonction Haskell est une relation entre un ou plusieurs paramètres (/argument/) et un résultat.   On la définit à l'aide d'une équation, comme suit~:

#+BEGIN_SRC haskell
double x = x + x
#+END_SRC

Ici, une fonction nommée `double` a un paramètre $x$ et renvoie le résultat $x + x$.
 
** Programmation fonctionnelle
La programmation fonctionnelle est un style de programmation qui favorise l'utilisation des fonctions.  Haskell est un langage fonctionnel parce les fonctions y jouent un rôle de premier plan.

Java, C++, Python  sont des langages  /impératifs/ parce qu'on y définit *comment faire* les calculs et non *quels résultats* avoir. Voici par exemple comment on programme la somme des entiers de $1$ à $n$ en style impératif,

#+BEGIN_SRC java
  int total = 0;
  for (int count = 1; count <= 1; count ++)
      total = total + count;
#+END_SRC
on décrit ci-dessus comment faire le calcul.

Voici un exemple du même programme avec un style fonctionnel.
#+BEGIN_SRC haskell
sum [1..n]
#+END_SRC
Ici, on définit ce que l'on veut comme résultat.  Pour cela, on fait appel à deux fonctions `[1..n]` qui renvoie la liste des entiers de $1$ à $n$ et ensuite à la fonction `sum`.

** Caractéristiques d'Haskell 
Voici quelqu'unes des caractéristiques du langage Haskell.  Il permet:
- les listes en compréhension
- les fonctions récursives,  c'est-à-dire des fonctions qui s'appellent elle-même.
- des programmes concis
- les fonctions de haut niveau (/higer-order functions/), des fonctions qui utilisent d'autre fonction comme paramètre ou résultat.
 c'est-à-dire qu'une fonction peut s'appliquer à une autre fonction.
- un typage évolué des entrées et sorties des fonctions
- une évaluation paresseuse (/lazy evalutation/), seuls les résultats utilisés sont calculés.

** Un peu d'histoire
Haskell découle du /lambda calculus/  développé dans les années 30 par Alonzo Church.   Il est aussi inspiré du Lisp (années 50), premier langage à base de liste.  Depuis 1987, il existe un comité pour le développement d'Haskell rassemblant des informaticiens de renom.  Au moins trois récipiendaires du prix ACM Turing Award ont participé au développement de Haskell.  Le langage est nomé en honneur à  Haskell Curry un logisticien Britanique.  

** Exemples de programmes Haskell

*** Faire la somme d'une liste de nombre
    On peut définir la fonction `somme` comme suit:
 #+BEGIN_SRC haskell
   somme [] = 0
   somme (n:ns) = n + somme ns
 #+END_SRC
et l'appeller ainsi:
 #+BEGIN_SRC haskell :results drawer
   somme [1,2,3]
 #+END_SRC


 En Haskell, toutes les fonctions ont un type. Celui de `somme` est :
 #+RESULTS:
 : somme :: Num a => [a] -> a

  Cela veut dire que pour une liste d'éléments de type `a` de la classe de type `Num`,  la fonction `somme` renvoie un seul élément de type `a`.   Il y a de nombreux types en Haskell et plusieurs types de nombres (ie. de la classe `Num`).

  Les types Haskell donnent des informations sur les fonctions. Ils permettent d'éviter beaucoup d'erreurs avant même l'exécution du programme.

*** Trier
Voici un autre exemple Haskell pour un programme de tri
#+BEGIN_SRC haskell -i
  tri_vite [] = []
  tri_vite (x:xs) = tri_vite plus_petits ++  [x] ++ tri_vite plus_grands
                 where
                   plus_petits = [a | a <- xs, a <= x]
                   plus_grands =  [b | b <- xs, b > x]
#+END_SRC
Nous reviendrons sur cet exemple plus tard.

* De quoi avons-nous besoin pour commencer ?
** GHCi : Glasgow Haskell Compilater Interactif 
Comme pour tout programme, il nous faut un éditeur de texte.  Celui avec lequel vous êtes le plus confortable est souvent le meilleur.  Ensuite il faut un compilateur Haskell.  Lorsque vous programmerez vous aurez donc deux fenêtres ouvertes. L'une avec l'éditeur, l'autre avec le compilateur.

Le compilateur que nous allons installer est le plus commun.  Il s'appelle [[https://www.haskell.org/downloads/][Glasgow Haskell Compilater (GHC)]].  Installez-le en suivant en suivant les instructions du lien.

La version interactive du compilateur est pratique pour apprendre et c'est ce que nous utiliserons pour notre cours.  Sachez toute fois que l'on peut compiler un programme de la façon suivante:
#+BEGIN_SRC bash  -i
ghc -O2 nom_du_programme.hs
#+END_SRC
ou encore 
#+BEGIN_SRC bash
ghc --make mon nom_du_programme.hs
#+END_SRC


  Une fois ghci installé, tester le.  Vous devriez voir quelque chose comme cela:
   #+BEGIN_SRC bash  -i
mlk@teur ~ $ ghci
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
Prelude> 
   #+END_SRC

À gauche, '>' est l'invite de commande.   Vous voyez écrit aussi 'Prelude'.  C'est une bibliothèque de fonction chargé par défaut dans le compilateur.

Le système attend votre commande.  Essayer les commandes suivantes:

 #+BEGIN_SRC haskell
 > 2+3*4
 #+END_SRC

 #+RESULTS:
 : 14

 #+BEGIN_SRC haskell
 > (2+3)*4
 #+END_SRC

 #+RESULTS:
 : 20

 #+BEGIN_SRC haskell
 > sqrt (3^2 + 4^2)
 #+END_SRC

 #+RESULTS:
 : 5.0

** Prélude
La bibliothèque de départ d'Haskell contient un nombre important de fonctions, notamment des fonctions qui s'appliquent à des listes.   Les éléments des listes sont notés entre crochets, exemple
#+BEGIN_SRC haskell
[1,2,3,4,5]
#+END_SRC

Nous donnons ici les définitions et des exemples des fonctions les plus souvent utilisés.

*** head
 Sélectionne le premier élément d'une liste non vide

#+BEGIN_SRC haskell
head  [1,2,3,4,5]
#+END_SRC

#+RESULTS:
: 1

*** tail
 Enlève le premier élément d'une liste  mon vide.
#+BEGIN_SRC haskell
tail [1,2,3,4,5]
#+END_SRC

#+RESULTS:
: [2,3,4,5]

*** !! (index)
 Sélectionne le $n^{ième}$ élément d'une liste non vide.   Notez que le premier indice est 0.
#+BEGIN_SRC haskell
[1,2,3,4,5]  !! 2
#+END_SRC

#+RESULTS:
: 3

*** take
 Sélectionne les n premiers éléments d'une liste.
#+BEGIN_SRC haskell
take 3 [1,2,3,4,5]
#+END_SRC

#+RESULTS:
: [1,2,3]

*** drop
 Supprime les n premiers éléments d'une liste.
#+BEGIN_SRC haskell
drop 3 [1,2,3,4,5]
#+END_SRC

#+RESULTS:
: [4,5]

*** length
 Calcule la longueur d'une liste.
#+BEGIN_SRC haskell
length [1,2,3,4,5]
#+END_SRC

#+RESULTS:
: 5

*** sum
 Fait la somme d'une liste de nombre.
#+BEGIN_SRC haskell
sum [1,2,3,4,5]
#+END_SRC

#+RESULTS:
: 15

*** product
 Calcule le produit des éléments d'une liste.
#+BEGIN_SRC haskell
product [1,2,3,4,5]
#+END_SRC

*** ++ (concatène)
Concatène (ou rassemble) deux listes en une seule.
#+BEGIN_SRC haskell
[1,2,3] ++ [4,5]
#+END_SRC

#+RESULTS:
: [1,2,3,4,5]

*** reverse
 Renverse les éléments d'une liste.
#+BEGIN_SRC haskell
reverse [1,2,3,4,5]
#+END_SRC

#+RESULTS:
: [5,4,3,2,1]

 # Voir l'appendice pour une liste des fonctions les plus souvent utilisé de la bibliothèque standard prélude.

** Comment appeler une fonction
 Les paramètres d'une fonction sont simplement séparés par des espaces.    Les parenthèses précisent la priorité des opérations sachant que l'application d'une fonction est prioritaire sur les opérations standards mathématiques, ainsi :
#+BEGIN_SRC haskell
f a + b
#+END_SRC
veut dire $f(a) + b$ et non $f(a+b)$, et 
#+BEGIN_SRC haskell
f a b + c*d
#+END_SRC
veut dire $f(a, b) + cd$ et non $f(a,b+cd)$. 

Voici une table associant notation mathématique et notation Haskell

| notation mathématique  | notation Haskell |
|------------------------+------------------|
| $f(x)$                 | f x              |
| $f(x,y)$               | f x y            |
| $f(g(x))$              | f (g x)          |
| $f(x,g(y))$            | f x (g y)        |
| $f(x)g(y)$             | f x * g y        |

** Scripts Haskell
  Les scripts Haskell ont généralement pour extensions '.hs'.    
 Supposons que nous ayons le code suivant dans un fichier appelé 'test.hs'
 #+BEGIN_SRC haskell
   double x = x + x
   
   quadruple x = double (double x)
 #+END_SRC

 Ce programme  définit deux fonctions mai il n'affiche rien, et il ne demande rien à l'utilisateur non plus.
Pour tester les fonctions, il est pratique de l'ouvrir dans ghci  comme suit:
   #+BEGIN_SRC bash  -i
ghci test.hs
  #+END_SRC
 Cela va charger en mémoire les fonctions et nous pourront les appeler à l'intérieur de ghci
#+BEGIN_SRC haskell
> quadruple 10
40
> take (double 2) [1,2,3,4,5,6,7,8]
[1,2,3,4]
#+END_SRC

Noter que lorsque  nous effectuons une modification dans le fichier 'test.hs', `ghci` ne prend pas en compte automatiquement les modifications.  Il faut utiliser la commande `:reload` (avec les :).

Par exemple,  modifions 'test.hs' en lui ajoutant les deux fonctions suivantes:
#+BEGIN_SRC haskell
factorielle n = product [1..n]

moyenne ns = sum ns  `div` length ns
#+END_SRC
Puis dans ghci, il faut écrire avant de pouvoir tester les nouvelles fonctions.
#+BEGIN_SRC bash
> :reload
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, one module loaded.

> factorielle 10
3628800
#+END_SRC

 Des commandes importantes de ghci à connaître sont :
 - :? ou :help,  pour afficher l'aide de ghci;
 - :browse /module/,  pour montrer toutes les définitions chargées par le module;
 - :doc /fonction/,  pour avoir la documenation d'une fonction;
 - :i ou :info /objet/, pour avoir des informations sur un object;
 - :l ou :load /fichier/, pour charger un module;
 - :q ou :quit,  pour sortir du ghci;
 - :r ou :reload /fichier/,  pour recharger un module qui vien d'être modifié;
 - :t ou :type /objet/,  pour connaître le type d'un objet.

Par exemple:
 #+BEGIN_SRC bash
 > :doc head
 #+END_SRC
renvoie
:  Extract the first element of a list, which must be non-empty.

** Règle de nommage des fonctions et des variables

 Le nom des fonctions et de leurs paramètres doivent commencer avec lettre une minuscule et peuvent ensuite contenir 0 ou plusieurs caractères suivant `a-zA-Z0-9'_` .

Comme dans tous langages de programmation, certains mots-clefs ont des significations spéciales et ils ne peuvent pas désigner des variables ou des fonctions. En Haskell ces mots sont les suivants:

: case class data default deriving do else foreing if import in infix infixl infixr instance let module newtype of the type where

*** Convention pour les noms de variables
Par convention, on appelle 'n', 'x', et 'cs' les variables qui contient respectivement des nombres, des valeurs quelconques et des caractères.
On ajoute 's' aux noms des variables pour désigner une liste ou un ensemble.  Par exemple,  on écrira `ns`  pour une liste de nombres, ou `xs`  pour une liste de variables quelconques et `css`  pour une liste de caractères.

***  Disposition du code
 Comme dans python,  Haskell utilise des espaces pour grouper les expressions ensemble.  Dans le code ci-dessous,
#+BEGIN_SRC haskell -i
  a = b + c
      where
        b = 1
        c = 2

  d = a * 2
#+END_SRC
`b` et `c` sont des variables définies localement dans la fonction `a`.

 On peut rajouter des accolades et séparer les définitions avec des ;.
#+BEGIN_SRC haskell
  a = b + c
      where
        {b = 1;
         c = 2};
  
  d = a * 2;
#+END_SRC
Ce qui permet dde réécrire le code sur une seule ligne.
#+BEGIN_SRC haskell
  a=b+c where {b=1; c=2}; d=a*2;
#+END_SRC

**** Indentation
Comme les éditeurs de texte interprètent différemment les tabulations,  il est préférable d'utiliser des espaces plutôt que des tabulations, pour l'indentation.   L'idéal et que son éditeur transforme automatiquement les tabulations en espaces.

Par convention on utilise 8 espaces pour indenter le code.

**** Commentaires
***** Simples

 Les commentaires simples commencent avec le symbole `--`.   Ils doivent tenir sur une ligne, comme ci-dessous:
#+BEGIN_SRC haskell
-- Factorielle des n premiers entiers
factorielle n = product [1..n]
#+END_SRC

***** Imbriqués
 Les commentaires imbriqués sont encadrés par `{-` et `-}`.
 Ils peuvent s'étendre sur plusieurs lignes et contenir des commentaires.   Ils sont pratiques pour commenter  des blocs de code entiers, comme ci-dessous:
#+BEGIN_SRC haskell
  {-  3 fonctions du fichier test.hs commentées
  
  double x = x + x
  
  quadruple x = double (double x)
  
  -- Factorielle des n premiers entiers
  factorielle n = product [1..n]
  -}
  
  moyenne ns = sum ns  `div` length ns 
#+END_SRC

Voyons maintenant plus en détail ce qui fait l'une des forces de Haskell, son système de typage.

** Exercices 

*** Exercice n°1
 Mettez les parenthèses sur les expressions numéériques suivantes
 $2^3*4$, $2*3+4*5$  et $2+3*4^5$

*** Exercice n°2
 Corrigez les trois erreurs de syntaxe dans le script ci-dessous et vérifiez qu'il fonctionne dans `ghci`
#+BEGIN_SRC haskell
  N = a 'div' length xs
      where 
        a = 10
       xs = [1,2,3,4,5]
#+END_SRC

 Écrire ce script en une seule ligne.


*** Exercice n°3
 La fonction `init` renvoie la dernière partie d'une liste par exemple
#+BEGIN_SRC haskell
init [1,2,3,4,5]
#+END_SRC
: [1,2,3,4]

 Définissez cette fonction de deux façons différentes avec les fonctions vu dans ce chapitre

* Types et Classes de type
Commençons par définir les types de base, puis ceux des listes et des fonctions.  Nous finirons en parlant dans classe de types.  

On utilisera la commande ':t' dans ghci pour voir les types des objets.

** Types de base
Les types suivant  sont définis par défaut dans /Prelude/.

*** Bool -- les booléens
#+BEGIN_SRC haskell
:t True
#+END_SRC

#+RESULTS:
: True :: Bool

#+BEGIN_SRC haskell
  :t False 
#+END_SRC

#+RESULTS:
: False :: Bool

 Lorsque l'on demande  le type de `True` ou `False`  la réponse est `Bool`.   En Haskell, tous ce qui suit les symboles `::` indique le type de l'objet.

Les opérateurs classiques sur les booléens sont `&&`, `||` et `not`.

*** Char -- caractères
 On utilise les guillemets simples pour noter un caractère.
#+BEGIN_SRC haskell
:t 'a'
#+END_SRC

#+RESULTS:
: 'a' :: Char

On peut aussi utiliser la valeur numérique (décimal ou hexadécimal) telle que définie par [[https://en.wikipedia.org/wiki/List_of_Unicode_characters#Latin_script][le standard unicode]].   Cela est utile pour saisir des caractères de contrôles, comme '@@latex:$\backslash{}$n@@' (nouvelle ligne) ou '@@latex:$\backslash{}$t@@' (tabulation).



#+BEGIN_SRC haskell
:t '\97'
#+END_SRC

#+RESULTS:
: '\97' :: Char
#+BEGIN_SRC haskell
:t '\x61'
#+END_SRC
: '\x61' :: Char

#+BEGIN_SRC haskell
('\97' == 'a') && ('a' == '\x61')
#+END_SRC
: True


****  Fonction sur les caractères
     :PROPERTIES:
     :OPTIONS: num:nil
     :END:

Il existe de nombreuses fonctions sur les caractères, notamment contenue dans la bibliothèque `Data.Char` que l'on peut charger avec
#+BEGIN_SRC haskell
import Data.Char
#+END_SRC
Un exemple 
#+BEGIN_SRC haskell
:t toUpper
#+END_SRC
: toUpper :: Char -> Char

Ce type veut dire que `toUpper` prend en entrée un caractère et renvoie un caractère en résultat.

#+BEGIN_SRC haskell
toUpper 'a'
#+END_SRC

#+RESULTS:
: 'A'

*** String -- chaînes de caractères
Les `String` sont encadrés par des guillemets doubles.  Ce sont des séquences de caractères.
#+BEGIN_SRC haskell
:t "efgh"
#+END_SRC
: "efgh" :: [Char]

*** Int --  entiers à précision fixe
Les `Int` sont des entiers, par exemple -100, 9 ou 0.    Ils sont compris entre $-2^{63}$  et $2^{63}-1$.   En dehors de cet intervalle, les résultats sont chaotiques.
# combien de bytes pour stoquer ses nombres.

#+BEGIN_SRC haskell
2^63 - 1
#+END_SRC
: 9223372036854775807

9 223 372 036 854 775 807 est positif, mais si on lui ajoute 1 et que l'on force le type `Int` on a
#+BEGIN_SRC haskell
2^63 :: Int
#+END_SRC
: -9223372036854775808
un nombre négatif.  On a dépassé la borne $2^63-1$

*** Integer --  entiers sans précision fixée

Les `Integer` sont des entiers aussi grands que ce que permet la mémoire de l'ordinateur.

#+BEGIN_SRC haskell
2^63 :: Integer
#+END_SRC
: 9223372036854775808
Cette fois ci le résultat est positif.
Le désavantage des `Integers` c'est qu'ils sont plus lents à traiter que les `Int`.

*** Float --   nombres à virugle de précision simple
Les `Float` représentent les nombres décimaux, par exemple -12.34, 1.0 ou 3.1415927 (notez le point à la place de la virgule).   Leur taille en mémoire est limité et leur précision dépend de la taille du nombre, par exemple la précision de 
#+BEGIN_SRC haskell
sqrt 2 :: Float
#+END_SRC
: 1.4142135
est de 7 chiffres après la virgule, alors que celle de 

#+BEGIN_SRC haskell
sqrt 9999 :: Float
#+END_SRC
: 99.995
est de 3 chiffre seulement.

`sqrt` est une fonction la librairie /Prelude/ qui calcule la racine carrée un nombre.

*** Double --  nombres à virgule avec deux fois plus de précision
Ce type est similaire à `Float`  mais avec deux fois plus de place en mémoire afin d'accroître la précision.

#+BEGIN_SRC haskell
sqrt 2 :: Double
#+END_SRC
: 1.4142135623730951

Ci-dessus la précision est maintenant de 16 et ci-dessous elle est maintenant de 14.
#+BEGIN_SRC haskell
sqrt 9999 :: Double
#+END_SRC
: 99.99499987499375

Notez qu'il faut toujours faire attention aux problèmes d'arrondis lorsque l'on utilise ces types de nombre pour des calculs précis.


Nous venons de voir qu'il existe plusieurs types de nombre, `Int`, `Integer`, `Float`, et `Double`.    Nous pourront les regrouper dans la classe de type `Num` que nous détaillerons plus tard.

** Types liste

 Une liste est une *séquence* d'éléments de *même type*.   Elle les  encadre avec des crochets et les séparer par des virgules.   On note $[T]$ le type de la liste dont tous les éléments sont de type $T$, par exemple :

#+BEGIN_SRC haskell
:t  [False, True, False ] 
#+END_SRC
: [False, True, False ] :: [Bool]
#+BEGIN_SRC haskell
:t  ['a', 'b', 'c', 'd']
#+END_SRC
: ['a', 'b', 'c', 'd'] :: [Char]

 Un peu plus compliqué
#+BEGIN_SRC haskell
:t "Zéro"
#+END_SRC
: "Zéro" :: [Char]
On remarque qu'une chaîne de caractères est une liste de caractères.

Une liste peut aussi contenir d'autre liste.
#+BEGIN_SRC haskell
:t  ["Un", "Deux", "Trois"]
#+END_SRC
: ["Un", "Deux", "Trois"] :: [[Char]]

Le nombre d'éléments d'une liste s'appelle /length/.  La liste `[]` est  vide, elle a une longueur nulle.   Les listes qui n'ont qu'un seul élément  comme `[False]` ou `['a']` sont appelés /singleton/.

Il n'y a pas de restrictions sur le type d'élément que peut contenir une liste ou sur sa taille.   Cette dernière peut même être infinie.

** Types tuple

 Le tuple est une *séquence* finie d'éléments potentiellement *de type différent*.   On le note entre les parenthèses `()` et ses éléments sont séparés par des virgules.   On écrira $(T_1, T_2, \cdots{}, T_n)$  le type d'un tuple contenant des éléments de type $T_1, T_2 \cdots{} T_n$

#+BEGIN_SRC haskell
:t (False, True)
#+END_SRC
: (False, True) :: (Bool, Bool)

#+BEGIN_SRC haskell
:t ('a', "Bob", True)
#+END_SRC
: ('a', "Bob", True) :: (Char, [Char], Bool)

La longueur d'un tube est appelée /arity/.   Le tuple de longueur zéro `()`  est le tuple vide, mais attention les singletons tuples n'existe pas car leur notation serait confondu avec l'usage mathématique des parenthèses.  Les parenthèses dans `(1+3)*4` doivent être comprise pour leur signification mathématique.  Elles ne désignent pas un tuple.


Évidement, les tuples peuvent contenir d'autres tuples.
#+BEGIN_SRC haskell
:t (False, (True, "Alpha"), [('b','c')])
#+END_SRC

#+RESULTS:
: (False, (True, "Alpha"), [('b','c')])
:   :: (Bool, (Bool, [Char]), [(Char, Char)])

 Il n'y a pas de limite quant au type des éléments contenus dans un tuple, mais leur taille est forcément finie.


** Types fonction
 Une fonction est une relation entre des paramètres d'un certain type et un résultat qui peut-être d'un autre type.   On note $T_1 -> T_2$  le type de toutes les fonctions qui mettent en relation  un paramètre de type $T_1$  avec un résultat de type $T_2$.   Par exemple,
#+BEGIN_SRC haskell
:t not 
#+END_SRC

#+RESULTS:
: not :: Bool -> Bool

#+BEGIN_SRC haskell
:t even
#+END_SRC

#+RESULTS:
: even :: Integral a => a -> Bool

Notez le symbole `=>`.  Il indique une contrainte de classe.   le type `a`  doit appartenir à la classe de type `Integral`.  Cette classe que nous détaillerons plus tard est une classe pour les types numériques pour lesquelles les opérations  `div` et `mod` sont définies.

`even` (est pair) est une fonction qui renvoie `True` si le nombre est pair et `False` sinon.    

*** Fonction avec plusieurs paramètres et résultat
 Si une fonction a plusieurs paramètres, on peut les passer en tant que tuple.  

#+BEGIN_SRC haskell
  ajouter :: (Int, Int) -> Int
  ajouter (x,y) = x+y
#+END_SRC
Par convention, en Haskell, on fait précéder la définition d'une fonction par son type.   Cela sert de documentation et facilite le débogage.

Les résultats peuvent aussi être des listes, par exemple
#+BEGIN_SRC haskell
  zéro_à :: Int -> [Int]
  zéro_à n = [0..n]
#+END_SRC

Notez que les fonctions ne sont pas obligatoirement définies sur tous l'ensemble de leur type (ou domaine).    La fonction `head` définie sur les listes,  ne l'est pas pour la liste vide.
#+BEGIN_SRC haskell
:t head
#+END_SRC

#+RESULTS:
: head :: [a] -> a

#+BEGIN_SRC haskell
head []
#+END_SRC

#+RESULTS:
: *** Exception: Prelude.head: empty list

Nous venons de voir comment définir des fonctions avec plusieurs variables, mais il existe une autre approche qui fait la force de Haskell.  Ce sont les fonctions curryfiées.

** Fonction curryfiées (/Curried functions/) 
Les fonctions qui prennent leur argument un par un et qui renvoie des fonctions s'appellent fonctions curryfiées ou /curried function/.  En Haskell, une fonction peut renvoyer une fonction comme résultat.

Comparons la fonction `ajouter` curryfiée ci-dessous à celle non currifiée du chapitre précédent.
#+BEGIN_SRC haskell
  ajouter' :: Int -> (Int -> Int)
  ajouter' x y = x+y
#+END_SRC

La fonction `ajouter` curryfiée  prend un paramètre une entrée (un `Int`) et renvoie une fonction qui transforme un `Int` en `Int` (`Int->Int`).   Au chapitre précédent la fonction `ajouter`, non curryfié, qui prenait  2 paramètres en entrée et qui renvoyait un seul `Int` comme résultat.   Toutes les fonctions à plusieurs paramètres peuvent être curryfiées. L'avantage c'est la concision du code et sa lisibilité qui font éviter les bugs..

Voici un autre exemple de fonction curryfiée
#+BEGIN_SRC haskell
  mult :: Int -> (Int -> (Int -> Int))
  mult x y z = x*y*z
#+END_SRC
`mult` renvoie une fonction qui renvoie une fonction qui renvoie un `Int`

#+BEGIN_SRC haskell
mult x y z
#+END_SRC
 veut  dire
#+BEGIN_SRC haskell
((mult x) y) z
#+END_SRC

 Par convention on omettra les parenthèses au niveau des types, ainsi
#+BEGIN_SRC haskell
  mult :: Int -> (Int -> (Int -> Int))
#+END_SRC
 est équivalent à
#+BEGIN_SRC haskell
  mult :: Int -> Int -> Int -> Int
#+END_SRC


** Type Polymorphique
Nous avons  la fonction `head`.  Elle renvoie le premier élément d'une liste quel que soit le type de cet élément.
#+BEGIN_SRC haskell
head [1,2,3,4]
#+END_SRC
: 1

#+BEGIN_SRC haskell
head ["Soumahoro", "Kanté"]
#+END_SRC
: Soumahoro

#+BEGIN_SRC haskell
head "Kirina"
#+END_SRC
: 'K'

C'est donc une fonction qui s'applique à plusieurs types.  Cette spécificité est précisée lorsqu'on regarde son type.
#+BEGIN_SRC haskell
:t head
#+END_SRC
: head :: [a] -> a

Son type fait apparaître une *variable de type* (/type variable/) `a`.  Les variables de type sont notées avec des lettres minuscules par exemple `a`, `b`, ou `c`.

Un type qui fait appel à une variable de type est appelé *type polymorphique*.
*** Exemples de fonctions ayant des types polymorphiques
Regardons le type de certaines fonction courante en Haskell
**** fst

la fonction `fst` qui  extrait le premier élément d'une paire
#+BEGIN_SRC haskell
:t fst
#+END_SRC
: fst :: (a, b) -> a

`fst` a un type qui contient deux variables de type. C'est naturellement un type polymorphique.

#+BEGIN_SRC haskell
fst ("Palmier", 4)
#+END_SRC
: Palmier

**** take
`take` renvois les n premiers éléments d'une liste
: take :: Int -> [a] -> [a]

**** zip
`zip` Rassemble deux listes de type différent en une seule liste de couple
#+RESULTS:
: zip :: [a] -> [b] -> [(a, b)]

**** id
la fonction `id` identité  renvoie le paramètre à l'identique
: id :: a -> a

** Types surchargés,  Overloaded types
  Certaines fonctions s'appliquent à plusieurs types mais avec certaines contraintes. Par exemple la fonction (+)  s'applique `Int` et `Float`  mais pas aux listes.  On note cette contrainte /class constraint/  `C a =>`,   où C est le nom d'une classe de type et `a` une variable de type.   
 #+RESULTS:
 : (+) :: Num a => a -> a -> a

Cela veut dire que la fonction (+) s'applique à des types de la classe Num (ou numérique).

 Un type qui contient les contraintes de classe est appelé un *type surchargé* ou /overloaded type/.

  Voici d'autres exemples
 #+RESULTS:
 : negate :: Num a => a -> a
 : abs ::Num a => a -> a

** Classes de base
 Une /class/ est un ensemble de type pour lesquelles certaines opérations (appelées méthodes) sont définies.

 Voici les classes de base définies par Haskell

*** Eq -- les types égalité
 Cette classe contient les types qui peuvent être comparés  en utilisant les méthodes suivantes

#+RESULTS:
: (==) :: a -> a -> Bool
: (/=) :: a -> a -> Bool

 Tous les types de base, les listes et les tuples, sont des instances de cette classe de type.

*** Ord --  les types  ordonnés
 Cette classe contient tous les types de la classe égalité `Eq` et qui, en plus, supportent les méthodes 6 suivantes:

#+RESULTS:
: (<) :: a -> a -> Bool
: (>) :: a -> a -> Bool
: (<=) :: a -> a -> Bool
: (>=) :: a -> a -> Bool
: min :: a -> a -> a
: max :: a -> a -> a

 Tous les types de base sont des instances de cette classe de type.   Les listes et les tuples, aussi, si les types de leurs éléments  sont instance de cette classe.

#+BEGIN_SRC haskell
('a', 10) < ('a', 100)
#+END_SRC

#+RESULTS:
: True

#+BEGIN_SRC haskell
[1,2,3] > [0,20,4,32]
#+END_SRC

#+RESULTS:
: True

Notez que les listes et tuples sont rangées comme dans un dictionnaire, en comparant l'ordre des éléments  un par un.

#+BEGIN_SRC haskell
('a','b') < ('a', 10)
#+END_SRC

#+RESULTS:
: : error:
:    • No instance for (Num Char) arising from the literal ‘10’
:    • In the expression: 10
:      In the first paramètre of ‘(<)’, namely ‘('a', 10)’
:      In the expression: ('a', 10) < ('a', 'b')

** Show --  les types que l'on peut afficher
 Cette classe contient tous les types dont les valeurs peuvent être converties en chaîne de caractères avec la méthode suivante:

#+RESULTS:
: show :: a -> String

- exemples :
#+BEGIN_SRC haskell
show [1,2,3]
#+END_SRC

#+RESULTS:
: [1,2,3]

#+BEGIN_SRC haskell
show ('a', False)
#+END_SRC

#+RESULTS:
: ('a',False)

** Num --  les types numériques
La classe de type `Num` comprend les `Int`, `Integer`, `Float` et  `Double`.  De façon général, elle comprend  tous les types qui supportent les six méthodes suivantes :
#+RESULTS:
: (+) :: a -> a -> a
: (-) :: a -> a -> a
: (*) :: a -> a -> a
: negate :: a -> a
: abs :: a -> a
: signum :: a -> a

Si l'on regarde le type du nombre 4, par exemple
#+BEGIN_SRC haskell
:t 4
#+END_SRC
: 4 :: Num p => p

On voit qu'il doit être de la catégorie Num.

La fonction `signum` renvoie le signe d'un nombre.
#+BEGIN_SRC haskell
signum (-3)
#+END_SRC
: -1
Notez que les parenthèses sont importantes.  Si on les oublie `signum` essayera de s'appliquer sur le symbole '-'.

** Integral 
 Ce sont les types de la classe Num,  mais qui en plus supporte les deux  méthodes suivantes :
#+RESULTS:
: div :: a -> a -> a
: mod :: a -> a -> a

 Il s'agit la division euclidienne et du modulo.

** Fractional
 Ce sont les types numériques qui, en plus, supportent les 2 méthodes suivantes:
#+RESULTS:
: (/) :: a -> a -> a
: recip :: a -> a

#+BEGIN_SRC haskell
:doc recip
#+END_SRC

#+RESULTS:
:  l'inverse (d'une fraction)

** Exercices

*** Exerice n°1
Quels sont les types des valeurs suivantes ?
#+BEGIN_SRC haskell
['a','b','c']
('a','b','c')
[(False, 'O'), (True,'1')]
([False,True], ['0','1'])
[tail, init, reverse]
#+END_SRC

*** Exercice n°2
 écrire des définitions quelconque mais correct et qui ont les types suivants.
#+BEGIN_SRC haskell
  bools :: [Bool]
  nums :: [[Int]]
  add : Int -> Int -> Int -> Int
  copy :: a -> (a,a)
  apply :: (a->b) -> a -> b
#+END_SRC

*** Exercice n°3
 trouver manuellement les types des fonctions suivantes ?

#+BEGIN_SRC haskell
second xs = head (tail xs)
échange (x,y) = (y,x)
pair x y = (x,y)
double x = x*2
palindrome xs = reverse xs == xs
deuxfois f x = f (fx)
#+END_SRC

 Prenez en compte les éventuelles contraintes de type
 vérifiant suite ce que vous avez trouvé à l'aide GHCi

* Déclaration de fonctions
** En utilisant les fonctions existantes
 La façon la plus simple de faire des fonctions et d'utiliser  des fonctions qui existent déjà.
 #+BEGIN_SRC haskell
   impair :: Integral a => a -> Bool
   impair n = n `mod` 2 == 0
 #+END_SRC
Ici, on fait appel à l'opérateur `mod`.  On verra ce qu'est un opérateur plus loin.
#+BEGIN_SRC haskell
   séparer :: Int -> [a] -> ([a],[a])
   séparer = n xs = (take n xs, drop n xs)
#+END_SRC

Ici, on fait appelle à `take` et `drop` et ci-dessous simplement à `/`.

#+BEGIN_SRC haskell
   inverse :: Fractional a => a -> a
   inverse n = 1/n
#+END_SRC

** Expressions conditionnelles
#+BEGIN_SRC haskell
  abs' :: Int -> Int
  abs' n = if n >= 0 then n else -n
  
  signum' :: Int -> Int
  signum' n = if n < 0 then 
                  -1
              else
                  if n == 0 then
                      0
                  else
                      1
#+END_SRC

** Gardes
À la place des expressions conditionnelles,  on peut utiliser des équations gardées /guarded equations/.  Un garde c'est un prédicat qui peut être vrai ou faux.   On le note sous forme d'équation ou d'inéquation, juste après un `|`.    Une fonction en utilise généralement plusieurs.
Ils permettent de choisir les instructions à éxecuter. Seule la première des expressions dont le garde est vérifiée est exécutée.  Si un garde est faux, on regarde le deuxième, puis le troisième et ainsi de suite.

#+BEGIN_SRC haskell
  abs'' n | n >= 0 = n
          | otherwise = -n
#+END_SRC
`|`  se lit 'tel que'.  Dans la définition de la fonction `abs` il y a 2 guardes. ` n >= 0` et `otherwise`.  Ce dernier guarde est toujours vrai.

 L'avantage des gardes est qu'ils clarifient le code.

Un autre exemple
#+BEGIN_SRC haskell
  signe n | n < 0 = -1
          | n == 0 = 0
          | otherwise = 1
#+END_SRC

** Motifs (/pattern matching/)

 Beaucoup de fonctions ont des définitions intuitives.  On peut les construite en utilisant une suite de motifs.  
Les motifs sont un peu comme pour les gardes qui permettent de choisir branche de code utiliser, mais ils s'appliquent directement aux arguments.  

Par exemple pour la fonction suivante, en fonction des valeurs des paramètres on affichera soit `True` soit `False`.

#+BEGIN_SRC haskell
et :: Bool -> Bool -> Bool
True `et` True = True
True `et` False = False
False `et` True = False
False `et` False = False
#+END_SRC

Dans cette définition on peut rassembler les trois dernières expressions grâce au joker '_'  qui remplace n'importe quelle valeurs.  La définition de la fonction devient alors:

#+BEGIN_SRC haskell
et :: Bool -> Bool -> Bool
True `et` True = True
_ `et` _ = False
#+END_SRC

*** motifs avec des tuples
 On peut aussi utiliser des tuples dans un motif.  
#+BEGIN_SRC haskell
  premier :: (a,b) -> a
  premier (a,_) = a
#+END_SRC
Ici, on selectionne les tuples de deux éléments et on renvoie le premier de ses éléments, ignorant le second.

*** motifs avec des listes

La même technique s'applique pour les listes.   Un motif de liste, avec une taille donnée, sélectionnera toutes les listes de cette taille.

#+BEGIN_SRC haskell
  test :: [Char] -> Bool 
  test ['a',_,_] = True
  test _ = False
#+END_SRC

La fonction `test` renverra `True` pour toutes les listes d'exactement trois éléments si elles commencent par le caractère 'a'.

Avec les list, on peut aussi utiliser l'opérateur ':' (/cons/).  il permet de construire une liste ou de décomposer les listes.

#+BEGIN_SRC haskell
1 :  [2,3]  == [1,2,3]
#+END_SRC
: True

Il ne faut pas le confondre avec l'opérateur de concaténation '++', qui s'utilise comme suit:
#+BEGIN_SRC haskell
[1] ++ [2,3] == [1,2,3]
#+END_SRC
: True

Voici deux exemples:
*** Entête d'une liste
#+BEGIN_SRC haskell
  entête :: [a] -> a
  entête (x:_) = x 
#+END_SRC

*** Queue d'une liste
#+BEGIN_SRC haskell
  queue :: [a] -> [a]
  queue (_:xs) = xs
#+END_SRC

** Expressions lambda

On peut définir des fonctions sans leur donner de nom.  On appelle ces fonctions /lambda/.  On définie leur paramètre avec la barre oblique `\` et la flèche `->` indique le résultat.

#+BEGIN_SRC haskell
\x -> x + x
#+END_SRC
est la fonction qui prend une variable x et renvoie son double.
On peut l'appeller comme cela :
#+BEGIN_SRC haskell
(\x -> x + x) 3
#+END_SRC
: 6

 Le nombre de variables des fonctions lambda n'est pas limité.

#+BEGIN_SRC haskell
  \x -> (\y -> x + y)
#+END_SRC
est l'écriture lambda de la fonction ajouter qui a deux paramètres

 Ce type de notation est utile pour définir des fonctions à l'intérieur d'autres fonctions.  Par exemple, voici la fonction `impaires` qui génèrent les premiers nombres impairs.     À la place d'écrire
#+BEGIN_SRC haskell
  impaires :: Int -> [Int]
  impaires n = map f [0..n-1]
               where f x = x*2 +1
#+END_SRC
on peut noter
#+BEGIN_SRC haskell
  impaires' :: Int -> [Int]
  impaires' map (\x -> x*2 +1) [0..n-1]
#+END_SRC

La fonction /map/  applique a un ensemble de valeurs, la fonction passé comme son première paramètre.

** Opérateurs
 Un opérateur est une fonction à deux paramètres qui s'écrit entre ses paramètres, par exemple $2 + 3$.   N'importe quelle fonction avec deux paramètres peut être converti en opérateur l'encadrant par des accents graves /back-quotes/, par exemple avec la division entière :
#+BEGIN_SRC haskell
10 `div` 3
#+END_SRC
: 3

On peut aussi curryfier n'importe quel opérateur en  l'encadrant avec des parenthèses, par exemple
#+BEGIN_SRC haskell
(+) 2 3
#+END_SRC
: 5

De façon générale si `#` est un opérateur alors on a :
:  (#)  équivaut \x -> (\y -> x # y)
:  (x #) équivaut \y -> x # y
:  (# y) équivaut \x -> x # y

par exemple 
: (1/) équivaut à  \x -> 1/x
#+BEGIN_SRC haskell
(1/) 4
#+END_SRC
: 0.25

et 
: (/2) équivaut à  \x -> x/2
#+BEGIN_SRC haskell
(/2) 33
#+END_SRC
: 16.5

** Exerices

*** Exercice n°1
 En utilisant les fonctions de la librairie 'Prelude' définit une fonction appelé `moitié` qui prend une liste d'éléments et qui renvoie un tuple contenant les deux moitiés de cette liste.
#+BEGIN_SRC haskell
  moitié :: [a] -> ([a],[a])
#+END_SRC

 La fonction doit renvoyer une erreur si la liste n'a pas un nombre pair d'éléments.

*** Exercice n°2
 Définit, de trois façons différentes, une fonction 'troisième' qui prend une liste d'éléments et qui renvoie le troisième élément de cette liste.
#+BEGIN_SRC haskell
  troisième :: [a] -> a
#+END_SRC

**** En utilisant les fonctions `head` et `tail`

**** en utilisant l'opérateur d'indice '!!'

**** en utilisant la correspondance de motif

*** Exercice n°3
Définir,  de trois façons différentes, la fonction 'boutsécurisé' qui se comporte comme la fonction `tail`  sauf qu'en cas de liste vide, elle renvoie la liste passée en paramètre.   Vous pouvez utiliser la fonction `null` de 'Prelude' pour savoir si la liste est vide
#+BEGIN_SRC haskell
  boutsécurisé :: [a] ->[a]
  null :: [a] -> Bool
#+END_SRC

**** En utilisant des expressions conditionnelles

**** En utilisant des équations gardées

**** En utilisant la correspondance de motif

*** Exercice n°4
définir l'opérateur `(ou)` de la même façon que ce que nous avons fait pour `(et)`

* Listes en compréhension
Une liste en compréhension est une liste définie en utilisant les éléments d'une autre liste.  En mathématiques, la liste des carrés des 5 premiers entiers notée en compréhension s'écrit $$\{x^2 | x \in [1\cdots{} 5]\}$$.

En Haskell on note
#+BEGIN_SRC haskell
  [x^2 | x <- [1..5 ]]
#+END_SRC
: [1,4,9,16,25]

On appelle la liste utilisé un /générateur/.  On peut en utiliser plusieurs, par exemple
#+BEGIN_SRC haskell
  [(x,y) | x <- [1,2,3],  y <- "aB"]
#+END_SRC
: [(1,'a'),(1,'B'),(1,'c'),(1,'d'),(2,'a'),(2,'B'),(2,'c'),(2,'d'),(3,'a'),(3,'B'),(3,'c'),(3,'d')]
génère la liste des couples dont le premier élément est 1, 2 ou 3 et le deuxième 'a' ou 'B'.

L'ordre des générateurs est important.
#+BEGIN_SRC haskell
  [(x,y) | y <- "aB", x <- [1,2,3]]
#+END_SRC
: [(1,'a'),(2,'a'),(3,'a'),(1,'B'),(2,'B'),(3,'B')]

C'est le second qui change plus vite.

** Filtres /Guards/
Dans les listes en  compréhension on peut utiliser des filtres (ou /guards/) pour limiter les valeurs du générateurs à prendre en compte.
Les guardes viennent après le symbole ',', par exemple :

   #+BEGIN_SRC haskell
     diviseurs_de :: Int -> [Int]
     diviseurs_de n = [x | x <- [1..n], n `mod` x == 0]
   #+END_SRC

** la fonction zip
La fonction `zip` est souvent utilisé avec les listes en compréhension.  C'est une fonction qui crée une liste de paires en prenant deux  éléments dans deux listes différentes, jusqu'à épuisement de l'une d'elles.

#+BEGIN_SRC haskell
zip "abcd" [1..10]
#+END_SRC
: [('a',1),('b',2),('c',3),('d',4)]

On peut s'en servire pour créer des paires, à partir d'une même liste.
#+BEGIN_SRC haskell
paires :: [a] -> [(a,a)]
paires xs = zip xs (tail xs)
#+END_SRC
Ce qui donne
#+BEGIN_SRC haskell
paires [1..5]
#+END_SRC
: [(1,2),(2,3),(3,4),(4,5)]

On peut ainsi définir une fonction qui vérifie si une liste et triée.
#+BEGIN_SRC haskell
  est_triée :: Ord a => [a] -> Bool 
  est_triée xs = and [x <= y | (x,y)  <- paires xs]
#+END_SRC
Vérifions avec
#+BEGIN_SRC haskell
est_triée [1,2,3,10,5]
#+END_SRC
: False

** Exercices
*** Exercice n°1
En utilisant une liste en compréhension donner l'expression qui calcule la somme des carrés des cent premiers entiers.
$1^2+2^2+\cdots{}+100^2$

*** Exercice n°2
 Soi un système de coordonnées sur une grille de taille $m\times n$  définie par  un couple $(x,y)$ avec $0\leq x \leq m$ et $0 \leq y \leq n$.
 En utilisant les fonctions standard définir la fonction 'grille'  qui renvoie les coordonnées de tous les points d'une crise dont les dimensions sont passées en paramètre.
#+BEGIN_SRC haskell
grille :: Int -> Int -> [(Int,Int)]
#+END_SRC
#+BEGIN_SRC bash  -i
> grille 1 2
#+END_SRC
: [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]

*** Exercice n°3
 Définir une fonction `réplique` qui prend en paramètre un entier $n$ et une valeur et qui renvoie une liste où la valeur est répliquée $n$ fois.

#+BEGIN_SRC haskell
réplique :: Int -> a -> [a]
#+END_SRC

#+BEGIN_SRC bash  -i
> réplique 3 True
#+END_SRC
: [True, True, True]

* Fonctions récursives

** Concepts de bases
 Une fonction récursive et une fonction qui s'appelle elle-même. On peut définir la fonction `factorielle` récursivement.
#+BEGIN_SRC haskell
  factorielle :: Int -> Int
  factorielle 0 = 1
  factorielle x = x * factorielle (x - 1)
#+END_SRC
Ce n'est pas la façon la plus rapide à calculer mais cela est très lisible.

** Récursion et listes
 Voici d'autres exemples de fonctions récursive avec des listes en paramètre:

*** Produit
    #+BEGIN_SRC haskell
      produit :: Num a => [a] -> a
      produit [] = 0
      produit (n:ns) = n * produit ns
    #+END_SRC

*** Longueur
 #+BEGIN_SRC haskell
   longueur :: [a] -> Int
   longueur [] = 0
   longueur (_:xs) = 1 + longueur xs
 #+END_SRC
*** Renverse
 #+BEGIN_SRC haskell
   renverse :: [a] -> [a]
   renverse [] = []
   renverse (x:xs) = reverse xs ++ [x] 
 #+END_SRC

*** Coupler
Les fonctions récursives peuvent aussi avoir plusieurs paramètres.

La fonction `coupler` fait comme le `zip` et on la définie comme suit:
#+BEGIN_SRC haskell
  coupler :: [a] -> [b] -> [(a,v)]
  coupler [] _ = []
  coupler _ [] = []
  coupler (x:xs) (y:ys) = (x,y) : coupler xs ys
#+END_SRC
*** Décapiter
La fonction `décapiter` qui supprime les n premiers éléments d'une liste.
#+BEGIN_SRC haskell
  décapiter :: Int -> [a] -> [a]
  décapiter 0 xs = xs
  décapiter _ [] = []
  décapiter n (_:xs) = décapiter (n-1) xs
#+END_SRC

** Récursions multiples

 Une fonction récursive peut s'appeler elle-même plusieurs fois,  par exemple, ici,  pour construire la suite de fibonacci : 
#+BEGIN_SRC haskell
  fibo :: Int -> Int
  fibo 0 = 0
  fibo 1 = 1
  fibo n = fibo (n-2) + fibo (n-1)
#+END_SRC
et ici pour définir un algorithme de tri_rapide
#+BEGIN_SRC haskell
    tri_rapide :: Ord a => [a] -> [a]
    tri_rapide [] = []
    tri_rapide (x:xs) = tri_rapide plus_petits ++ [x] ++ tri_rapide plus_grands
                        where 
                          plus_petits = [a | a <- xs, a <= xs]
                          plus_grands = [b | b <- xs, b > xs]
#+END_SRC

** Récursion mutelle
Les fonctions récursives en Haskell peuvent aussi faire appellent à des fonctions qui les rappellent.  Par exemple `est_pair` à besoin de `est_impair` 
#+BEGIN_SRC haskell
  est_pair :: Int -> Bool 
  est_pair 0 = True
  est_pair n = est_impair (n-1)
#+END_SRC
  qui a besoin de `est_pair`.
#+BEGIN_SRC haskell
  est_impair :: Int -> Bool
  est_impair 1 = True
  est_impair n = est_pair (n-1)
#+END_SRC
Ou encore la fonction `indices_pairs` qui selection un élément s sur deux dans une liste en partant du premier, à besoin des `indices_impairs`
#+BEGIN_SRC haskell
  indices_pairs :: [a] -> [a]
  indices_pairs [] = []
  indices_pairs (x:xs) = x : indices_impairs xs
#+END_SRC

qui a besoin de `indice_pairs`.
#+BEGIN_SRC haskell
  indices_impairs :: [a] -> [a]
  indices_impairs [] = []
  indices_impairs (_:xs) = indices_pairs xs
#+END_SRC
** Conseils pour construire des fonctions récursives.
La récursion,  c'est comme le vélo.  Cela semble simple lorsque l'on voit quelqu'un d'autre en faire mais il faut de la pratique pour bien y arriver.

Voici une démarche à suivre et quelques conseils pour y arrriver.
*** Définir le type de la fonction
#+BEGIN_SRC haskell
  produit :: [Int] -> Int
#+END_SRC
*** Identifier les cas importants
#+BEGIN_SRC haskell
produit [] = 
produit (n:ns) = 
#+END_SRC
*** Écrire la définition de cas simples
#+BEGIN_SRC haskell
produit [] = 1
produit (n:ns) = 
#+END_SRC

*** Écrire la définition des autres cas
#+BEGIN_SRC haskell
produit [] = 1
produit (n:ns) = n * produit ns
#+END_SRC

*** Généraliser et simplifier
Dans notre exemple la fonction `produit` peut s'appliquer à tous les types de la classe `Num`.
#+BEGIN_SRC haskell
  produit :: Num a => [a] -> a
#+END_SRC

 On va voir dans le prochain chapitre que la manière dont nous venons de définir la fonction `produit`  est très générique et Haskell permet de coder une multitude de fonction de cette manière à l'aide de la fonction /foldr/.   

`produit` se  définit alors en une ligne.
#+BEGIN_SRC haskell
produit = foldr (*) 1
#+END_SRC

** Exerices

*** Exercices n°1
Définir une fonction récurcive 'euclide' qui calcule le plus grand diviseur de deux nombres non-négatifs.  
#+BEGIN_SRC haskell
  euclide :: Int -> Int -> Int
#+END_SRC
Si les deux nombre sont égaux, alors ce nombre est le résultat, sinon le plus petit est soustrait au plus grand.

*** Exercice n°2
Définir de façon récursive les fonctions suivantes:

**** `et_liste`  
#+BEGIN_SRC haskell
  et_liste :: [Bool] -> Bool 
#+END_SRC
décide si tout les valeurs de la liste sont vraie

**** 'concatène'
#+BEGIN_SRC haskell
  concatène :: [[a]] -> [a]
#+END_SRC
Concatène une liste de listes

**** 'est_élément'
#+BEGIN_SRC haskell
  est_élément :: Eq a => a -> [a] -> Bool 
#+END_SRC
Décide si un élément fait partie d'une liste.

*** Exercice n°3
Définie une fonction récursive `fusionne`  qui rassemble deux listes en une seule triée.
#+BEGIN_SRC haskell
  fusionne :: Ord a => [a] -> [a] -> [a]
#+END_SRC
par exemple
#+BEGIN_SRC bash  -i
>merge [2,5,6] [1,3,4]
#+END_SRC
: [1,2,3,4,5,6]

* Fonctions de haut-niveau (higher-order)
Une fonction de haut-niveau est une fonction qui *prend d'autre(s) fonction(s) en paramètre*.

** Exemples de base
Les fonctions de ce types les plus courantes sont `map` et `filter`. 
`map`  applique la fonction passé en paramètre sur une liste d'éléments.
#+BEGIN_SRC haskell
  map (\x -> x^2) [1..5]
#+END_SRC
: [1,4,9,16,25]

`filter` renvoie une liste d'élément sélectionné dans une autre liste selon un prédicat passé sous forme de fonction en paramètre, par exemple:

#+BEGIN_SRC haskell
filter (\[x,y] -> x == y)  [ "aa", "ab", "Aa", "AA"] 
#+END_SRC
: ["aa","AA"]

 Nous donnons maintenant des exemples courants de fonctions de haut-niveau.
** fold
- `foldr`  applique un opérateur sur une liste en allant de la droite à la gauche.  Elle est souvent appelée /reduce/ dans d'autre langage.
#+BEGIN_SRC haskell
  longueur :: [a] -> Int
  longueur = flodr (\_ n -> 1 +n) 0
#+END_SRC

- `foldl`:  applique un opérateur sur une liste en allant de la droite à la gauche.
** Composition
L'opérateur `(.)` permet de faire de la composition de fonction.  Cela simplifie et de clarifie le code.   À la place de noter 
#+BEGIN_SRC haskell
impaire n = not (paire n)
#+END_SRC
on note
#+BEGIN_SRC haskell
impaire  = not . pair
#+END_SRC
À la place de 
#+BEGIN_SRC haskell
repéter f x = f (f x)
#+END_SRC
on écrit
#+BEGIN_SRC haskell
répeter = f . f
#+END_SRC
et à la place de 
#+BEGIN_SRC haskell
somme_carré_positif ns = sum (map (^2) (filter paire ns))
#+END_SRC
on écrira
#+BEGIN_SRC haskell
somme_carré_positif = sum . map (^2) . filter pair
#+END_SRC

** Exercices

*** Exercice n°1
Redéfinir la liste en compréhension $[f x | x <- xs, p x]$ en utilisant les fonctions de haut niveau `map` et `filter`
**** solution
#+BEGIN_SRC haskell
-- [f x | x <- xs, p x] ?
exo1 :: (a -> b) -> [a] -> (a -> Bool) -> [b]
exo1 f xs p = [f x | x <- xs, p x]

exo1sol :: (a -> b) -> [a] -> (a -> Bool) -> [b]
exo1sol f xs p = map f (filter p xs)
-- map f filter p xs
#+END_SRC

*** Exercice n°2
Redéfinir les fonctions `map f` et `filter p` en utilisant `foldr`

**** solution

#+BEGIN_SRC haskell
-- exo3 redefine map f and filter p using foldr

map_ :: (a -> b) -> [a] -> [b]
map_ f xs = foldr apply_f [] xs
  where apply_f x y = (f x : y)

map__ :: (a -> b) -> [a] -> [b]
map__ f xs = foldr (\x y -> f x : y) [] xs


filter_ :: (a -> Bool) -> [a] -> [a]
filter_ p xs = foldr filter_p [] xs
  where filter_p x y
          | p x = (x:y)
          | otherwise = y
#+END_SRC

*** Exercice n°3
En utilisant `foldl` définr la fonction dec2Int
qui converti une liste de nombre en entier
#+BEGIN_SRC haskell
  dec2Int :: [Int] -> Int
#+END_SRC

#+BEGIN_SRC bash  -i
dec2int [2,3,4,5]
#+END_SRC
: 2345

**** sol
#+BEGIN_SRC haskell
-- exo 4 p. 105
-- Using foldl, deﬁne a function dec2int :: [Int] -> Int that converts a
-- decimal number into an integer. For example:

dec2int :: [Int] -> Int
dec2int xs = foldl (\x y -> 10 * x + y) 0 xs

#+END_SRC
* Déclaration des Types et des Classes
Les noms de types de classe *commencent avec une majuscule*.

** Comment déclarer de nouveau type
*** types
 On peut les définir en utilisant des types existants
 #+BEGIN_SRC haskell
   type Position = (Int, Int)
   type Transistion = Pos -> Pos
 #+END_SRC

 Les types récursifs sont interdits.
 #+BEGIN_SRC haskell
   type Arbre = (Int, [Tree]) --interdit
 #+END_SRC

 Par contre, on peut utiliser les classes de type
 #+BEGIN_SRC haskell
 type Paire a = (a,a)
 type Dico k v = [(k,v)]
 #+END_SRC
*** data
 `data` permet de créer un nouveau type en énumérant les différentes valeurs possibles.

 #+BEGIN_SRC haskell
   data Déplacement = Nord | Sud | Est | Ouest deriving Show
  
   déplace :: Déplacement -> Position -> Position
   déplace North (x,y) = (x,y+1)
   déplace Sud (x,y) = (x, y-1)
   déplace Est (x,y) = (x+1,y)
   déplace Ouest (x,y) = (x-1,y)
 #+END_SRC
 `data` permet d'utiliser des variables et des paramètres.  Par exemple :
 #+BEGIN_SRC haskell
   data Forme = Cercle Float | Rectangle Float Float
  
   faire_carré :: Float -> Forme
   faire_carré n = Rectangle n n
  
   faire_cercle :: Float -> Forme
   faire_cercle r = Cercle r
  
   calculer_aire :: Forme -> Float
   calculer_aire (Rectangle long larg) = long * larg
   calculer_aire (Cercle r) = pi * r^2
 #+END_SRC
 Ci-dessus, les constructeurs `Cercle` et `Rectangle` sont des fonctions constructeurs, à cause de leurs variables.  On le voit en demandant le type de `Cercle`.
 #+BEGIN_SRC haskell
 :t Cercle
 #+END_SRC
 : Cercle :: Float -> Forme

 - un autre exemple de type avec une variable
 #+BEGIN_SRC haskell
   data Maybe a = Nothing | Just a
  
   division_securisée :: Int -> Int -> Maybe Int
   division_securisée _ 0 :: Nothing
   division_securisée m n = Just (m `div` n)
 #+END_SRC

*** newtype
 La troisième façon de créer un type est en utilisant le mot clef `newtype`.
 #+BEGIN_SRC haskell
 newtype Entier_Naturel = N Int
 #+END_SRC

*** types récursifs
 Dans certains cas les définitions des types peuvent être récursives, par exemple
 #+BEGIN_SRC haskell
 data Naturel = Zero | Succ Naturel deriving Show
 data Arbre a = Feuille a | Noeud (Arbre a) a (Arbre a) deriving Show
 #+END_SRC

** Classes de type
Les classes de types ne sont possible que pour les types déclarés avec `data` et `newtype`.

Voici comment on déclare un classe de type en Haskell
#+BEGIN_SRC haskell
  class Eq a where 
      (==), (/=) :: a -> a -> Bool 
  
      x /= y = not (x==y)
#+END_SRC
et comment on instancie cette classe de type.
#+BEGIN_SRC haskell
  instance Eq Bool where
      False == False = True 
      True  == True  = True 
      _ == _ = False 
#+END_SRC

*** instances de type dérivées
Lors de la création d'un type il est possible de les faire dériver  de classe existante et il aura alors les méthodes par défaut de ces classes.

La dérivation se fait comme suit:
#+BEGIN_SRC haskell
  data Bool = False | True
            deriving (Eq, Ord, Show, Read)
#+END_SRC

Cela veut dire que la classe de type Bool hérite automatiquement des méthodes de base des classe `Eq`, `Ord`, `Show` et `Read`.

** Exercices


